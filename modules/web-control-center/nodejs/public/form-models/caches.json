{
  "general": [
    {
      "label": "Name",
      "type": "text",
      "model": "name",
      "required": true,
      "placeholder": "Input name"
    },
    {
      "label": "Mode",
      "type": "dropdown",
      "model": "mode",
      "placeholder": "PARTITIONED",
      "items": "modes",
      "tip": [
        "Cache modes:",
        "<ul>",
        "  <li>Partitioned - in this mode the overall key set will be divided into partitions and all partitions will be split equally between participating nodes.</li>",
        "  <li>Replicated - in this mode all the keys are distributed to all participating nodes.</li>",
        "  <li>Local - in this mode caches residing on different grid nodes will not know about each other.</li>",
        "</ul>"
      ]
    },
    {
      "label": "Atomicity",
      "type": "dropdown",
      "model": "atomicityMode",
      "placeholder": "ATOMIC",
      "items": "atomicities",
      "tip": [
        "Atomicity:",
        "<ul>",
        "  <li>Transactional - in this mode specified fully ACID-compliant transactional cache behavior.</li>",
        "  <li>Atomic - in this mode distributed transactions and distributed locking are not supported.</li>",
        "</ul>"
      ]
    },
    {
      "label": "Backups",
      "type": "number",
      "model": "backups",
      "placeholder": 0,
      "tip": [
        "Number of nodes used to back up single partition for partitioned cache."
      ]
    },
    {
      "label": "Read from backup",
      "type": "check",
      "model": "readFromBackup",
      "tip": [
        "Flag indicating whether data can be read from backup.",
        "If not set then always get data from primary node (never from backup)."
      ]
    }
  ],
  "advanced": [
    {
      "label": "Async back pressure control",
      "tip": [
        "Cache async back pressure settings."
      ],
      "fields": [
        {
          "label": "Max async concurrency",
          "type": "number",
          "model": "maxConcurrentAsyncOperations",
          "placeholder": 500,
          "tip": [
            "Maximum number of allowed concurrent asynchronous operations.",
            "If 0 then number of concurrent asynchronous operations is unlimited."
          ]
        }
      ]
    },
    {
      "label": "Memory",
      "tip": [
        "Cache memory settings."
      ],
      "fields": [
        {
          "label": "Mode",
          "type": "dropdown",
          "model": "memoryMode",
          "placeholder": "ONHEAP_TIERED",
          "items": "memoryModes",
          "tip": [
            "Memory modes:",
            "<ul>",
            "  <li>ONHEAP_TIERED - entries are cached on heap memory first.",
            "    <ul>",
            "      <li>If offheap memory is enabled and eviction policy evicts an entry from heap memory, entry will be moved to offheap memory. If offheap memory is disabled, then entry is simply discarded.</li>",
            "      <li>If swap space is enabled and offheap memory fills up, then entry will be evicted into swap space. If swap space is disabled, then entry will be discarded. If swap is enabled and offheap memory is disabled, then entry will be evicted directly from heap memory into swap.</li>",
            "    </ul>",
            "  </li>",
            "  <li>OFFHEAP_TIERED - works the same as ONHEAP_TIERED, except that entries never end up in heap memory and get stored in offheap memory right away. Entries get cached in offheap memory first and then get evicted to swap, if one is configured.</li>",
            "  <li>OFFHEAP_VALUES - entry keys will be stored on heap memory, and values will be stored in offheap memory. Note that in this mode entries can be evicted only to swap.</li>",
            "</ul>"
          ]
        },
        {
          "label": "Off-heap max memory",
          "type": "number",
          "model": "offHeapMaxMemory",
          "min": -1,
          "placeholder": -1,
          "hide": "backupItem.memoryMode == 'OFFHEAP_VALUES'",
          "tip": [
            "Sets maximum amount of memory available to off-heap storage.",
            "Possible values are:",
            "<ul>",
            "  <li>-1 - means that off-heap storage is disabled.</li>",
            "  <li>0 - Ignite will not limit off-heap storage (it's up to user to properly add and remove entries from cache to ensure that off-heap storage does not grow infinitely.</li>",
            "  <li>Any positive value specifies the limit of off-heap storage in bytes.</li>",
            "</ul>"
          ]
        },
        {
          "label": "Eviction policy",
          "type": "dropdown-details",
          "path": "evictionPolicy",
          "model": "kind",
          "placeholder": "Choose eviction policy",
          "items": "evictionPolicies",
          "hide": "backupItem.memoryMode == 'OFFHEAP_TIERED'",
          "tip": [
            "Cache expiration policy."
          ],
          "details": {
            "LRU": {
              "expanded": false,
              "fields": [
                {
                  "label": "Batch size",
                  "type": "number",
                  "path": "evictionPolicy.LRU",
                  "model": "batchSize",
                  "placeholder": 1,
                  "tip": ["Number of entries to remove on shrink."]
                },
                {
                  "label": "Max memory size",
                  "type": "number",
                  "path": "evictionPolicy.LRU",
                  "model": "maxMemorySize",
                  "placeholder": 0,
                  "tip": [
                    "Maximum allowed cache size in bytes."
                  ]
                },
                {
                  "label": "Max size",
                  "type": "number",
                  "path": "evictionPolicy.LRU",
                  "model": "maxSize",
                  "placeholder": 100000,
                  "tip": [
                    "Maximum allowed size of cache before entry will start getting evicted."
                  ]
                }
              ]
            },
            "RND": {
              "expanded": false,
              "fields": [
                {
                  "label": "Max size",
                  "type": "number",
                  "path": "evictionPolicy.RND",
                  "model": "maxSize",
                  "placeholder": 100000,
                  "tip": [
                    "Maximum allowed size of cache before entry will start getting evicted."
                  ]
                }
              ]
            },
            "FIFO": {
              "expanded": false,
              "fields": [
                {
                  "label": "Batch size",
                  "type": "number",
                  "path": "evictionPolicy.FIFO",
                  "model": "batchSize",
                  "placeholder": 1,
                  "tip": ["Number of entries to remove on shrink."]
                },
                {
                  "label": "Max memory size",
                  "type": "number",
                  "path": "evictionPolicy.FIFO",
                  "model": "maxMemorySize",
                  "placeholder": 0,
                  "tip": [
                    "Maximum allowed cache size in bytes."
                  ]
                },
                {
                  "label": "Max size",
                  "type": "number",
                  "path": "evictionPolicy.FIFO",
                  "model": "maxSize",
                  "placeholder": 100000,
                  "tip": [
                    "Maximum allowed size of cache before entry will start getting evicted."
                  ]
                }
              ]
            },
            "SORTED": {
              "expanded": false,
              "fields": [
                {
                  "label": "Batch size",
                  "type": "number",
                  "path": "evictionPolicy.SORTED",
                  "model": "batchSize",
                  "placeholder": 1,
                  "tip": ["Number of entries to remove on shrink."]
                },
                {
                  "label": "Max memory size",
                  "type": "number",
                  "path": "evictionPolicy.SORTED",
                  "model": "maxMemorySize",
                  "placeholder": 0,
                  "tip": [
                    "Maximum allowed cache size in bytes."
                  ]
                },
                {
                  "label": "Max size",
                  "type": "number",
                  "path": "evictionPolicy.SORTED",
                  "model": "maxSize",
                  "placeholder": 100000,
                  "tip": [
                    "Maximum allowed size of cache before entry will start getting evicted."
                  ]
                }
              ]
            }
          }
        },
        {
          "label": "Start size",
          "type": "number",
          "model": "startSize",
          "placeholder": 1500000,
          "tip": ["Initial cache size which will be used to pre-create internal hash table after start."]
        },
        {
          "label": "Swap enabled",
          "type": "check",
          "model": "swapEnabled",
          "tip": [
            "Flag indicating whether swap storage is enabled or not for this cache."
          ]
        },
        {
          "label": "Copy on read",
          "type": "check",
          "model": "copyOnRead",
          "tip": [
            "Flag indicating whether copy of of the value stored in cache should be created for cache operation implying return value.",
            "Also if this flag is set copies are created for values passed to CacheInterceptor and to CacheEntryProcessor."
          ]
        }
      ]
    },
    {
      "label": "Near cache",
      "tip": [
        "Near cache settings.",
        "Near cache is a small local cache that stores most recently or most frequently accessed data.",
        "Should be used in case when it is impossible to send computations to remote nodes."
      ],
      "fields": [
        {
          "label": "Enabled",
          "type": "check",
          "model": "nearCacheEnabled",
          "tip": [
            "Flag indicating whether to configure near cache."
          ]
        },
        {
          "label": "Start size",
          "type": "number",
          "path": "nearConfiguration",
          "model": "nearStartSize",
          "placeholder": 375000,
          "tip": [
            "Initial cache size for near cache which will be used to pre-create internal hash table after start."
          ]
        },
        {
          "label": "Eviction policy",
          "type": "dropdown-details",
          "path": "nearConfiguration.nearEvictionPolicy",
          "model": "kind",
          "placeholder": "Choose eviction policy",
          "items": "evictionPolicies",
          "tip": [
            "Cache expiration policy."
          ],
          "details": {
            "LRU": {
              "expanded": false,
              "fields": [
                {
                  "label": "Batch size",
                  "type": "number",
                  "path": "nearConfiguration.nearEvictionPolicy.LRU",
                  "model": "batchSize",
                  "placeholder": 1,
                  "tip": ["Number of entries to remove on shrink."]
                },
                {
                  "label": "Max memory size",
                  "type": "number",
                  "path": "nearConfiguration.nearEvictionPolicy.LRU",
                  "model": "maxMemorySize",
                  "placeholder": 0,
                  "tip": [
                    "Maximum allowed cache size in bytes."
                  ]
                },
                {
                  "label": "Max size",
                  "type": "number",
                  "path": "nearConfiguration.nearEvictionPolicy.LRU",
                  "model": "maxSize",
                  "placeholder": 100000,
                  "tip": [
                    "Maximum allowed size of cache before entry will start getting evicted."
                  ]
                }
              ]
            },
            "RND": {
              "expanded": false,
              "fields": [
                {
                  "label": "Max size",
                  "type": "number",
                  "path": "nearConfiguration.nearEvictionPolicy.RND",
                  "model": "maxSize",
                  "placeholder": 100000,
                  "tip": [
                    "Maximum allowed size of cache before entry will start getting evicted."
                  ]
                }
              ]
            },
            "FIFO": {
              "expanded": false,
              "fields": [
                {
                  "label": "Batch size",
                  "type": "number",
                  "path": "nearConfiguration.nearEvictionPolicy.FIFO",
                  "model": "batchSize",
                  "placeholder": 1,
                  "tip": ["Number of entries to remove on shrink."]
                },
                {
                  "label": "Max memory size",
                  "type": "number",
                  "path": "nearConfiguration.nearEvictionPolicy.FIFO",
                  "model": "maxMemorySize",
                  "placeholder": 0,
                  "tip": [
                    "Maximum allowed cache size in bytes."
                  ]
                },
                {
                  "label": "Max size",
                  "type": "number",
                  "path": "nearConfiguration.nearEvictionPolicy.FIFO",
                  "model": "maxSize",
                  "placeholder": 100000,
                  "tip": [
                    "Maximum allowed size of cache before entry will start getting evicted."
                  ]
                }
              ]
            },
            "SORTED": {
              "expanded": false,
              "fields": [
                {
                  "label": "Batch size",
                  "type": "number",
                  "path": "nearConfiguration.nearEvictionPolicy.SORTED",
                  "model": "batchSize",
                  "placeholder": 1,
                  "tip": ["Number of entries to remove on shrink."]
                },
                {
                  "label": "Max memory size",
                  "type": "number",
                  "path": "nearConfiguration.nearEvictionPolicy.SORTED",
                  "model": "maxMemorySize",
                  "placeholder": 0,
                  "tip": [
                    "Maximum allowed cache size in bytes."
                  ]
                },
                {
                  "label": "Max size",
                  "type": "number",
                  "path": "nearConfiguration.nearEvictionPolicy.SORTED",
                  "model": "maxSize",
                  "placeholder": 100000,
                  "tip": [
                    "Maximum allowed size of cache before entry will start getting evicted."
                  ]
                }
              ]
            }
          }
        }
      ]
    },
    {
      "label": "Query",
      "tip": [
        "Cache query settings."
      ],
      "fields": [
        {
          "label": "Escape all",
          "type": "check",
          "model": "sqlEscapeAll",
          "tip": [
            "If set then all the SQL table and field names will be escaped with double quotes.",
            "This enforces case sensitivity for field names and also allows having special characters in table and field names."
          ]
        },
        {
          "label": "Cached rows",
          "type": "number",
          "model": "sqlOnheapRowCacheSize",
          "placeholder": 10240,
          "tip": [
            "Number of SQL rows which will be cached onheap to avoid deserialization on each SQL index access."
          ]
        },
        {
          "label": "Long query timeout",
          "type": "number",
          "model": "longQueryWarningTimeout",
          "placeholder": 3000,
          "tip": [
            "Timeout in milliseconds after which long query warning will be printed."
          ]
        },
        {
          "type": "indexedTypes",
          "model": "indexedTypes",
          "tip": [
            "Collection of types to index."
          ]
        },
        {
          "label": "SQL functions",
          "type": "table-simple",
          "model": "sqlFunctionClasses",
          "editIdx": -1,
          "placeholder": "SQL function full class name",
          "tableTip": [
            "Collections of classes with user-defined functions for SQL queries."
          ],
          "tip": [
            "Class with user-defined functions for SQL queries."
          ]
        }
      ]
    },
    {
      "label": "Rebalance",
      "tip": [
        "Cache rebalance settings."
      ],
      "fields": [
        {
          "label": "Mode",
          "type": "dropdown",
          "model": "rebalanceMode",
          "placeholder": "ASYNC",
          "items": "rebalanceModes",
          "tip": [
            "Rebalance modes:",
            "<ul>",
            "  <li>Synchronous - in this mode distributed caches will not start until all necessary data is loaded from other available grid nodes.</li>",
            "  <li>Asynchronous - in this mode distributed caches will start immediately and will load all necessary data from other available grid nodes in the background.</li>",
            "  <li>None - in this mode no rebalancing will take place which means that caches will be either loaded on demand from persistent store whenever data is accessed, or will be populated explicitly.</li>",
            "</ul>"
          ]
        },
        {
          "label": "Pool size",
          "type": "number",
          "model": "rebalanceThreadPoolSize",
          "placeholder": 2,
          "tip": [
            "Size of rebalancing thread pool.<br>",
            "Note that size serves as a hint and implementation may create more threads for rebalancing than specified here (but never less threads)."
          ]
        },
        {
          "label": "Batch size",
          "type": "number",
          "model": "rebalanceBatchSize",
          "placeholder": "512 * 1024",
          "tip": [
            "Size (in bytes) to be loaded within a single rebalance message.",
            "Rebalancing algorithm will split total data set on every node into multiple batches prior to sending data."
          ]
        },
        {
          "label": "Order",
          "type": "number",
          "model": "rebalanceOrder",
          "placeholder": 0,
          "tip": [
            "If cache rebalance order is positive, rebalancing for this cache will be started only when rebalancing for all caches with smaller rebalance order (except caches with rebalance order 0) will be completed."
          ]
        },
        {
          "label": "Delay",
          "type": "number",
          "model": "rebalanceDelay",
          "placeholder": 0,
          "tip": [
            "Delay in milliseconds upon a node joining or leaving topology (or crash) after which rebalancing should be started automatically."
          ]
        },
        {
          "label": "Timeout",
          "type": "number",
          "model": "rebalanceTimeout",
          "placeholder": 10000,
          "tip": [
            "Rebalance timeout in milliseconds."
          ]
        },
        {
          "label": "Throttle",
          "type": "number",
          "model": "rebalanceThrottle",
          "placeholder": 0,
          "tip": [
            "Time in milliseconds to wait between rebalance messages to avoid overloading of CPU or network."
          ]
        }
      ]
    },
    {
      "label": "Statistics",
      "tip": [
        "Cache statistics and management settings."
      ],
      "fields": [
        {
          "label": "Statistics enabled",
          "type": "check",
          "model": "statisticsEnabled",
          "tip": [
            "Flag indicating whether statistics gathering is enabled on a cache."
          ]
        },
        {
          "label": "Management enabled",
          "type": "check",
          "model": "managementEnabled",
          "tip": [
            "Flag indicating whether management is enabled on this cache."
          ]
        }
      ]
    },
    {
      "label": "Store",
      "tip": [
        "Cache store settings."
      ],
      "fields": [
        {
          "label": "Store factory",
          "type": "dropdown-details",
          "path": "cacheStoreFactory",
          "model": "kind",
          "placeholder": "Choose store factory",
          "items": "cacheStoreFactories",
          "tip": [
            "Factory for persistent storage for cache data."
          ],
          "details": {
            "CacheJdbcPojoStoreFactory": {
              "expanded": true,
              "fields": [
                {
                  "label": "Data source bean",
                  "type": "text",
                  "path": "cacheStoreFactory.CacheJdbcPojoStoreFactory",
                  "model": "dataSourceBean",
                  "required": true,
                  "placeholder": "Bean name in Spring context",
                  "tip": [
                    "Name of the data source bean in Spring context."
                  ]
                },
                {
                  "label": "Dialect",
                  "type": "dropdown",
                  "path": "cacheStoreFactory.CacheJdbcPojoStoreFactory",
                  "model": "dialect",
                  "required": true,
                  "placeholder": "Choose JDBC dialect",
                  "items": "cacheStoreJdbcDialects",
                  "tip": [
                    "Dialect of SQL implemented by a particular RDBMS:",
                    "<ul>",
                    "  <li>Generic JDBC dialect.</li>",
                    "  <li>Oracle database.</li>",
                    "  <li>IBM DB2.</li>",
                    "  <li>Microsoft SQL Server.</li>",
                    "  <li>My SQL.</li>",
                    "  <li>H2 database.</li>",
                    "</ul>"
                  ]
                }
              ]
            },
            "CacheJdbcBlobStoreFactory": {
              "expanded": true,
              "fields": [
                {
                  "label": "user",
                  "type": "text",
                  "path": "cacheStoreFactory.CacheJdbcBlobStoreFactory",
                  "model": "user",
                  "required": true,
                  "tip": [
                    "User name for database access."
                  ]
                },
                {
                  "label": "Data source bean",
                  "type": "text",
                  "path": "cacheStoreFactory.CacheJdbcBlobStoreFactory",
                  "model": "dataSourceBean",
                  "required": true,
                  "placeholder": "Bean name in Spring context",
                  "tip": [
                    "Name of the data source bean in Spring context."
                  ]
                },
                {
                  "label": "Init schema",
                  "type": "check",
                  "path": "cacheStoreFactory.CacheJdbcBlobStoreFactory",
                  "model": "initSchema",
                  "tip": [
                    "Flag indicating whether DB schema should be initialized by Ignite (default behaviour) or was explicitly created by user."
                  ]
                },
                {
                  "label": "Create query",
                  "type": "text",
                  "path": "cacheStoreFactory.CacheJdbcBlobStoreFactory",
                  "model": "createTableQuery",
                  "placeholder": "SQL for table creation",
                  "tip": [
                    "Query for table creation in underlying database.",
                    "Default value: create table if not exists ENTRIES (key binary primary key, val binary)"
                  ]
                },
                {
                  "label": "Load query",
                  "type": "text",
                  "path": "cacheStoreFactory.CacheJdbcBlobStoreFactory",
                  "model": "loadQuery",
                  "placeholder": "SQL for load entry",
                  "tip": [
                    "Query for entry load from underlying database.",
                    "Default value: select * from ENTRIES where key=?"
                  ]
                },
                {
                  "label": "insert query",
                  "type": "text",
                  "path": "cacheStoreFactory.CacheJdbcBlobStoreFactory",
                  "model": "insertQuery",
                  "placeholder": "SQL for insert entry",
                  "tip": [
                    "Query for insert entry into underlying database.",
                    "Default value: insert into ENTRIES (key, val) values (?, ?)"
                  ]
                },
                {
                  "label": "Update query",
                  "type": "text",
                  "path": "cacheStoreFactory.CacheJdbcBlobStoreFactory",
                  "model": "updateQuery",
                  "placeholder": "SQL for update entry",
                  "tip": [
                    "Query fpr update entry in underlying database.",
                    "Default value: update ENTRIES set val=? where key=?"
                  ]
                },
                {
                  "label": "Delete query",
                  "type": "text",
                  "path": "cacheStoreFactory.CacheJdbcBlobStoreFactory",
                  "model": "deleteQuery",
                  "placeholder": "SQL for delete entry",
                  "tip": [
                    "Query for delete entry from underlying database.",
                    "Default value: delete from ENTRIES where key=?"
                  ]
                }
              ]
            },
            "CacheHibernateBlobStoreFactory": {
              "expanded": true,
              "fields": [
                {
                  "label": "Hibernate properties",
                  "type": "table-simple",
                  "path": "cacheStoreFactory.CacheHibernateBlobStoreFactory",
                  "model": "hibernateProperties",
                  "editIdx": -1,
                  "placeholder": "key=value",
                  "tip": [
                    "List of Hibernate properties.",
                    "For example: connection.url=jdbc:h2:mem:"
                  ]
                }
              ]
            }
          }
        },
        {
          "label": "Load previous value",
          "type": "check",
          "model": "loadPreviousValue",
          "tip": [
            "Flag indicating whether value should be loaded from store if it is not in the cache for following cache operations:",
            "<ul>",
            "  <li>IgniteCache.putIfAbsent()</li>",
            "  <li>IgniteCache.replace()</li>",
            "  <li>IgniteCache.replace()</li>",
            "  <li>IgniteCache.remove()</li>",
            "  <li>IgniteCache.getAndPut()</li>",
            "  <li>IgniteCache.getAndRemove()</li>",
            "  <li>IgniteCache.getAndReplace()</li>",
            "  <li>IgniteCache.getAndPutIfAbsent()</li>",
            "</ul>"
          ]
        },
        {
          "label": "Read-through",
          "type": "check",
          "model": "readThrough",
          "tip": [
            "Flag indicating whether read-through caching should be used."
          ]
        },
        {
          "label": "Write-through",
          "type": "check",
          "model": "writeThrough",
          "tip": [
            "Flag indicating whether write-through caching should be used."
          ]
        }
      ]
    },
    {
      "label": "Transaction",
      "tip": [
        "Cache transactions settings."
      ],
      "fields": [
        {
          "label": "Invalidate",
          "type": "check",
          "model": "invalidate",
          "tip": [
            "Invalidation flag for near cache entries in transaction.",
            "If set then values will be invalidated (nullified) upon commit in near cache."
          ]
        },
        {
          "label": "Default lock timeout",
          "type": "number",
          "model": "defaultLockTimeout",
          "placeholder": 0,
          "tip": [
            "Default lock acquisition timeout.",
            "If 0 then lock acquisition will never timeout."
          ]
        },
        {
          "label": "Manager finder",
          "type": "text",
          "model": "transactionManagerLookupClassName",
          "tip": [
            "Class name of transaction manager finder for integration for JEE app servers."
          ]
        }
      ]
    },
    {
      "label": "Write behind",
      "tip": [
        "Cache write behind settings.",
        "Write-behind is a special mode when updates to cache accumulated and then asynchronously flushed to persistent store as a bulk operation."
      ],
      "fields": [
        {
          "label": "Enabled",
          "type": "check",
          "model": "writeBehindEnabled",
          "tip": [
            "Flag indicating whether Ignite should use write-behind behaviour for the cache store."
          ]
        },
        {
          "label": "Batch size",
          "type": "number",
          "model": "writeBehindBatchSize",
          "placeholder": 512,
          "tip": [
            "Maximum batch size for write-behind cache store operations.",
            "Store operations (get or remove) are combined in a batch of this size to be passed to cache store."
          ]
        },
        {
          "label": "Flush size",
          "type": "number",
          "model": "writeBehindFlushSize",
          "placeholder": 10240,
          "tip": [
            "Maximum size of the write-behind cache.<br>",
            "If cache size exceeds this value, all cached items are flushed to the cache store and write cache is cleared."
          ]
        },
        {
          "label": "Flush frequency",
          "type": "number",
          "model": "writeBehindFlushFrequency",
          "placeholder": 5000,
          "tip": [
            "Frequency with which write-behind cache is flushed to the cache store in milliseconds."
          ]
        },
        {
          "label": "Flush threads count",
          "type": "number",
          "model": "writeBehindFlushThreadCount",
          "placeholder": 1,
          "tip": [
            "Number of threads that will perform cache flushing."
          ]
        }
      ]
    }
  ]
}
